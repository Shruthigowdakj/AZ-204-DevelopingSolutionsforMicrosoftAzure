

# Lab 02: Implement task processing logic by using Azure Functions

## Architecture diagram

![Architecture diagram depicting a user implementing task processing logic by using Azure Functions.](./media/az-204_02-archDiagram.png)

## Lab setup and pre-requisites

Before starting this lab, you must complete **Prerequisites** of this lab.

To install **C#** extension for this lab, follow the below steps in visual studio code:

1. Start Visual Studio Code.

     ![Visual Studio Code Icon](./media/vscode.jpg)

2. Select the **Extensions** blade from the left panel.
3. Search with **C#** and select **Install** to install the extension.

    ![](./media/vsds.png)

4. After installing C# extensions, close the Visual studio code.

# Exercise 1: Create Azure resources

## Task 1: Open the Azure portal

1. If you are not logged in, click on Azure portal shortcut that is available on the desktop and log in with Azure credentials.

1. To get the Azure credentials select the **Environment Details** tab from the lab environment details page.

    ![](./media/image-100.png)
    
1. On the Welcome to Microsoft Edge page, select **Start without your data** and on the help for importing Google browsing data page, select the **Continue without this data** button. Then, proceed to select **Confirm and start browsing** on the next page.

## Task 2: Create an Azure Storage account

1. In the Azure portal, use the **Search resources, services, and docs** text box to search for **Storage Accounts**, and then, in the list of results, select **Storage Accounts**.

1. On the **Storage accounts** blade, select **+ Create**.

1. On the **Create a storage account** blade, on the **Basics** tab, perform the following actions, and then select **Review**:

    | Setting                           | Action                                                       |
    | --------------------------------- | ------------------------------------------------------------ |
    | **Subscription** drop-down list   | Retain the default value.                                    |
    | **Resource group** section        | Select **Serverless-<inject key="DeploymentID" enableCopy="false"/>**                             |
    | **Storage account name** text box | Enter **funcstor<inject key="DeploymentID" enableCopy="false"/>**                                 |
    | **Region** drop-down list         | Select **(US) East US**.                                     |
    | **Performance** section           | Select the **Standard** option.                              |
    | **Redundancy** drop-down list     | Select **Locally-redundant storage (LRS)**.                  |
    
    The following screenshot displays the configured settings in the **Create a storage account** blade.

    ![Screenshot displaying the configured settings on the Create a storage account blade](./media/az-204_02-01.png)

1. On the **Review** tab, review the options that you selected during the previous steps.

1. Select **Create** to create the storage account by using your specified configuration.

    > **Note**: Wait for the creation task to complete before you proceed with this lab.

1. On the **Overview** blade, select the **Go to resource** button to navigate to the blade of the newly created storage account.

1. On the **Storage account** blade, in the **Security + networking** section, select **Access keys**.

1. On the **Access keys** blade, select **Show** to view the keys.

1. Review any one of the keys, and then copy the value of either of the **Connection string** boxes to the clipboard.

     > **Note**: It doesn't matter which connection string you choose. They are interchangeable.

1. Open Notepad, and then paste the copied connection string value to Notepad. You'll use this value later in this lab.

  > **Congratulations** on completing the task! Now, it's time to validate it. Here are the steps:

 - Navigate to the Lab Validation Page, from the upper right corner in the lab guide section.
 - Hit the Validate button for the corresponding task. If you receive a success message, you can proceed to the next task. 
 - If not, carefully read the error message and retry the step, following the instructions in the lab guide.
 - If you need any assistance, please contact us at labs-support@spektrasystems.com. We are available 24/7 to help you out.

## Task 3: Create a function app

1. In the Azure portal, use the **Search resources, services, and docs** text box to search for **Function App**, and then, in the list of results, select **Function App**.

1. On the **Function App** blade, select **+ Create**.

1. On the **Create Function App** blade, on the **Basics** tab, perform the following actions, and then select **Next: Hosting**:

    | Setting                          | Action                           |
    | -------------------------------- | -------------------------------- |
    | **Subscription** drop-down list  | Retain the default value.        |
    | **Resource group** section       | Select **Serverless-<inject key="DeploymentID" enableCopy="false"/>**          |
    | **Function App name** text box   | Enter **funclogic<inject key="DeploymentID" enableCopy="false"/>** |
    | **Publish** section              | Select **Code**                 |
    | **Runtime stack** drop-down list | Select **.NET**                |
    | **Version** drop-down list       | Select **6 (LTS)**                  |
    | **Region** drop-down list        | Select the **East US** region   |
    | **Operating System** section       | Select **Linux**                                  |
    | **Plan type** drop-down list       | Select **Consumption (Serverless)**               |

1. On the **Hosting** tab, perform the following actions, and then select **Review + create**:

    | Setting                            | Action                                             |
    | ---------------------------------- | -------------------------------------------------- |
    | **Storage account** drop-down list | Select the **funcstor<inject key="DeploymentID" enableCopy="false"/>** storage account. |

1. On the **Review + create** tab, review the options that you selected during the previous steps.

1.  **Create** to create the function app by using your specified configuration.
2. 
   ![EX-01-tsk-3](https://github.com/CloudLabs-MOC/AZ-204-DevelopingSolutionsforMicrosoftAzure/assets/120366375/e97dd42d-f375-4693-ad33-7065adcfc8b1)
   ![EX-01-tsk-3-2](https://github.com/CloudLabs-MOC/AZ-204-DevelopingSolutionsforMicrosoftAzure/assets/120366375/39c28143-094d-4496-bdad-a1be34e475d7)



    > **Note**: Wait for the creation task to complete before you move forward with this lab.
 
 > **Congratulations** on completing the task! Now, it's time to validate it. Here are the steps:

 - Navigate to the Lab Validation Page, from the upper right corner in the lab guide section.
 - Hit the Validate button for the corresponding task. If you receive a success message, you can proceed to the next task. 
 - If not, carefully read the error message and retry the step, following the instructions in the lab guide.
 - If you need any assistance, please contact us at labs-support@spektrasystems.com. We are available 24/7 to help you out.



### Review
In this exercise, you created all the resources that you'll use in this lab.

# Exercise 2: Configure a local Azure Functions project
Configuring a local Azure Functions project involves setting up a development environment on your local machine to create, test and debug Azure Functions before deploying them to the cloud.

## Task 1: Initialize a function project

1. On the taskbar, Search and select the **Command Prompt** icon.

1. Run the following command to change the current directory to the *C:\\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\\Allfiles\\Labs\\02\\Starter\\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. Run the following command to use the **Azure Functions Core Tools** to create a new local Azure Functions project in the current directory using the **dotnet** runtime:
    
    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **Note**: You can review the documentation to [create a new project][azure-functions-core-tools-new-project] using the **Azure Functions Core Tools**.
    
1. Close the **Command Prompt** application.

## Task 2: Configure a connection string

1. On the **Start** screen, select the **Visual Studio Code** tile.
1. On the **File** menu, select **Open Folder**.
1. In the **File Explorer** window that opens, browse to **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func**, and then select **Select Folder**.

1. On the **Visual Studio Code** pop-up select **Yes, I trust the authors**.
1. On the **Explorer** pane of the **Visual Studio Code** window, open the **local.settings.json** file.
1. Observe the current value of the **AzureWebJobsStorage** setting:

    ```json
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    ```

1. Update the value of the **AzureWebJobsStorage** by setting it to the **connection string** of the storage account that you recorded earlier in this lab.
1. Save the **local.settings.json** file.

## Task 3: Build and validate a project

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the *C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. Run the following command to **build** the .NET Core 3.1 project:

    ```powershell
    dotnet build
    ```

1. Close the **Command Prompt** application.

### Review
In this exercise, you created a local project that you'll use for Azure Functions development.

# Exercise 3: Create a function that's triggered by an HTTP request

## Task 1: Create an HTTP-triggered function

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. Run the following command to use the **Azure Functions Core Tools** to create a new function named **Echo** using the **HTTP trigger** template:

    ```powershell
    func new --template "HTTP trigger" --name "Echo"
    ```

    > **Note**: You can review the documentation to [create a new function][azure-functions-core-tools-new-function] using the **Azure Functions Core Tools**.

1. Close the currently running **Command Prompt** application.

## Task 2: Write HTTP-triggered function code

1. On the **Start** screen, select the **Visual Studio Code** tile.
1. On the **File** menu, select **Open Folder**.
1. In the **File Explorer** window that opens, browse to **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func**, and then select **Select Folder**.
1. On the **Explorer** pane of the **Visual Studio Code** window, open the  **Stater-func-Echo.cs** file.
1. In the code editor, observe the example implementation:

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;

    namespace func
    {
        public static class Echo
        {
            [FunctionName("Echo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");

                string name = req.Query["name"];

                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;

                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";

                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. Delete all the content within the **Echo.cs** file.
1. Add the following lines of code to add **using directives** for the **Microsoft.AspNetCore.Mvc**, **Microsoft.Azure.WebJobs**, **Microsoft.AspNetCore.Http**, and **Microsoft.Extensions.Logging** namespaces:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    ```

1. Create a new **public static** class named **Echo**:

    ```csharp
    public static class Echo
    { }
    ```

1. Observe the **Echo.cs** file again, which should now include:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;

    public static class Echo
    { }
    ```

1. Within the **Echo** class, add the following code block to create a new **public static** method named **Run** that returns a variable of type **IActionResult** and that also takes in variables of type **HttpRequest** and **ILogger** as parameters named *request* and *logger*:

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. Add the following code to append an attribute to the **Run** method of type **FunctionNameAttribute** that has its **name** parameter set to a value of **Echo**:

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        HttpRequest request,
        ILogger logger)
    { }
    ```

1. Add the following code to append an attribute to the **request** parameter of type **HttpTriggerAttribute** that has its **methods** parameter array set to a single value of **POST**:

    ```csharp
    [FunctionName("Echo")]
    public static IActionResult Run(
        [HttpTrigger("POST")] HttpRequest request,
        ILogger logger)
    { }
    ```

1. Observe the **Echo.cs** file again, which should now include the following code:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;

    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        { }
    }
    ```

1. In the **Run** method, enter the following line of code to log a fixed message:

    ```csharp
    logger.LogInformation("Received a request");
    ```

1. Enter the following line of code to echo the body of the HTTP request as the HTTP response:

    ```csharp
    return new OkObjectResult(request.Body);
    ```

1. Observe the **Echo.cs** file again, which should now include the following code:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;

    public static class Echo
    {
        [FunctionName("Echo")]
        public static IActionResult Run(
            [HttpTrigger("POST")] HttpRequest request,
            ILogger logger)
        {
            logger.LogInformation("Received a request");
            return new OkObjectResult(request.Body);
        }
    }
    ```

1. Select **Save** to save your changes to the **Echo.cs** file.

## Task 3: Test the HTTP-triggered function by using httprepl

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. Run the following command to run the function app project:

    ```powershell
    func start --build
    ```

    > **Note**: You can review the documentation to [start the function app project locally][azure-functions-core-tools-start-function] using the **Azure Functions Core Tools**.
    
1. On the taskbar, select the **Command Prompt** icon again to open a new instance of the application.
1. When you receive the open command prompt, run the following command to install and start the **httprepl** tool, setting the base Uniform Resource Identifier (URI) to ``http://localhost:7071``:

    ```powershell
    dotnet tool install -g Microsoft.dotnet-httprepl
    ```
    
    ```powershell
    httprepl http://localhost:7071
    ```

    > **Note**: An error message is displayed by the **httprepl** tool. This message occurs because the tool is searching for a Swagger definition file to use to traverse the API. Because your function project doesn't produce a Swagger definition file, you'll need to traverse the API manually.
1. When you receive the tool prompt, run the following command to browse to the relative **api** directory:

    ```powershell
    cd api
    ```

1. Run the following command to browse to the relative **echo** directory:

    ```powershell
    cd echo
    ```

1. Run the following command to run the **post** command, sending in an HTTP request body set to a numeric value of **3** by using the **\-\-content** option:

    ```powershell
    post --content 3
    ```

1. Run the following command to run the **post** command, sending in an HTTP request body set to a numeric value of **5** by using the **\-\-content** option:

    ```powershell
    post --content 5
    ```

1. Run the following command to run the **post** command, sending in an HTTP request body set to a string value of **Hello** by using the **\-\-content** option:

    ```powershell
    post --content "Hello"
    ```

1. Run the following command to run the **post** command, sending in an HTTP request body set to a JavaScript Object Notation (JSON) value of **{"msg": "Successful"}** by using the **\-\-content** option:

    ```powershell
    post --content "{"msg": "Successful"}"
    ```

1. Run the following command to exit the **httprepl** application:

    ```powershell
    exit
    ```

1. Close all currently running instances of the **Command Prompt** application.
   > **Note**: Once testing for exercises 4, 5, and 6 is completed, we can proceed to validate this exercise since these exercises are interdependent. 

### Review
In this exercise, you created a basic function that echoes the content sent through an HTTP POST request.

# Exercise 4: Create a function that triggers on a schedule

## Task 1: Create a schedule-triggered function

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to use the **Azure Functions Core Tools** to create a new function named **Recurring**, using the **Timer trigger** template:

    ```powershell
    func new --template "Timer trigger" --name "Recurring"
    ```

    > **Note**: You can review the documentation to [create a new function][azure-functions-core-tools-new-function] using the **Azure Functions Core Tools**.
    
1. Close the currently running **Command Prompt** application.

## Task 2: Observe function code

1. On the **Start** screen, select the **Visual Studio Code** tile.
1. On the **File** menu, select **Open Folder**.
1. In the **File Explorer** window that opens, browse to **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func**, and then select **Select Folder**.
1. On the **Explorer** pane of the **Visual Studio Code** window, open the **Recurring.cs** file.
1. In the code editor, observe the implementation:

    ```csharp
    using System;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Host;
    using Microsoft.Extensions.Logging;
    
    namespace func
    {
        public static class Recurring
        {
            [FunctionName("Recurring")]
            public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
            {
                log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");
            }
        }
    }
    ```

## Task 3: Observe function runs

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to run the function app project:

    ```powershell
    func start --build
    ```

    > **Note**: You can review the documentation to [start the function app project locally][azure-functions-core-tools-start-function] using the **Azure Functions Core Tools**.
1. Observe the function run that occurs about every five minutes. Each function run should render a simple message to the log.
1. Close the currently running **Command Prompt** application.

## Task 4: Update the function integration configuration

1. On the **Start** screen, select the **Visual Studio Code** tile.
1. On the **File** menu, select **Open Folder**.
1. In the **File Explorer** window that opens, browse to **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func**, and then select **Select Folder**.
1. On the **Explorer** pane of the **Visual Studio Code** window, open the **Recurring.cs** file.
1. In the code editor, observe the existing **Run** method signature:

    ```csharp
    [FunctionName("Recurring")]
    public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. Update the **Run** method signature code block to change the schedule to run once every **30 seconds**:

    ```csharp
    [FunctionName("Recurring")]
    public static void Run([TimerTrigger("*/30 * * * * *")]TimerInfo myTimer, ILogger log)
    ```

1. Select **Save** to save your changes to the **Recurring.cs** file.

## Task 5: Observe function runs

1. On the taskbar, select the **Command Prompt** icon.

1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to run the function app project:

    ```powershell
    func start --build
    ```
    
    > **Note**: You can review the documentation to [start the function app project locally][azure-functions-core-tools-start-function] using the **Azure Functions Core Tools**.
    
1. Observe the function run that occurs about every 30 seconds. Each function run should render a simple message to the log.

1. Close the currently running **Command Prompt** application.

1. Close the Visual Studio Code window.

### Review

In this exercise, you created a function that runs automatically based on a fixed schedule.

# Exercise 5: Create a function that integrates with other services

## Task 1: Upload sample content to Azure Blob Storage

1. On the Azure portal's **navigation** pane, select the **Resource groups** link.
1. On the **Resource groups** blade, select the **Serverless-<inject key="DeploymentID" enableCopy="false"/>** resource group that you created previously in this lab.
1. On the **Serverless-<inject key="DeploymentID" enableCopy="false"/>** blade, select the **funcstor** storage account that you created previously in this lab.
1. On the **Storage account** blade, select the **Containers** link in the **Data storage** section.
1. In the **Containers** section, select **+ Container**.
1. In the **New container** pop-up window, perform the following actions, and then select **Create**:

    | Setting                          | Action                           |
    | -------------------------------- | -------------------------------- |
    | **Name** text box  | Enter **content**.     |
    | **Public access level** drop-down list  | Select **Private (no anonymous access)**.     |

1. Return to the **Containers** section, and then select the recently created **content** container.
1. On the **Container** blade, select **Upload**.
1. In the **Upload blob** window, perform the following actions, and then select **Upload**:

    | Setting                          | Action                           |
    | -------------------------------- | -------------------------------- |
    | **Files** section  | Select the **Folder** icon.    |
    | **File Explorer** window  | Browse to **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter**, select the **settings.json** file, and then select **Open**.    |
    | **Overwrite if files already exist** check box  | Ensure that this check box is selected.   |

      > **Note**: Wait for the blob to upload before you continue with this lab.

## Task 2: Create an HTTP-triggered function

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to use the **Azure Functions Core Tools** to create a new function named **GetSettingInfo**, using the **HTTP trigger** template:

    ```powershell
    func new --template "HTTP trigger" --name "GetSettingInfo"
    ```

    > **Note**: You can review the documentation to [create a new function][azure-functions-core-tools-new-function] using the **Azure Functions Core Tools**.
1. Close the currently running **Command Prompt** application.

## Task 3: Write HTTP-triggered and blob-inputted function code

1. On the **Start** screen, select the **Visual Studio Code** tile.
1. On the **File** menu, select **Open Folder**.
1. In the **File Explorer** window that opens, browse to **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func**, and then select **Select Folder**.
1. On the **Explorer** pane of the **Visual Studio Code** window, open the **GetSettingInfo.cs** file.
1. In the code editor, observe the example implementation:

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;
    
    namespace func
    {
        public static class GetSettingInfo
        {
            [FunctionName("GetSettingInfo")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");
    
                string name = req.Query["name"];
    
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;
    
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";
    
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. Delete all the content within the **GetSettingInfo.cs** file.

1. Add the following lines of code to add **using directives** for the **Microsoft.AspNetCore.Http**, **Microsoft.AspNetCore.Mvc**, and **Microsoft.Azure.WebJobs** namespaces:

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    ```

1. Create a new **public static** class named **GetSettingInfo**:

    ```csharp
    public static class GetSettingInfo
    { }
    ```

1. Observe the **GetSettingInfo.cs** file again, which should now include the following code:

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;

    public static class GetSettingInfo
    { }
    ```

1. Within the **GetSettingInfo** class, add the following code block to create a new **public static** expression-bodied method named **Run** that returns a variable of type **IActionResult** and that also takes in variables of type **HttpRequest** and **string** as parameters named *request* and *json*:

    ```csharp
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

    > **Note**: You are only temporarily setting the return value to **null**.

1. Add the following code to append an attribute to the **Run** method of type **FunctionNameAttribute** that has its **name** parameter set to a value of **GetSettingInfo**:

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        HttpRequest request,
        string json)
        => null;
    ```

1. Add the following code to append an attribute to the **request** parameter of type **HttpTriggerAttribute** that has its **methods** parameter array set to a single value of **GET**:

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        string json)
        => null;
    ```

1. Add the following code to append an attribute to the **json** parameter of type **BlobAttribute** that has its **blobPath** parameter set to a value of **content/settings.json**:

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => null;
    ```

1. Add the following code to update the **Run** expression-bodied method to return a new instance of the **OkObjectResult** class passing in the value of the **json** method parameter as the sole constructor parameter:

    ```csharp
    [FunctionName("GetSettingInfo")]
    public static IActionResult Run(
        [HttpTrigger("GET")] HttpRequest request,
        [Blob("content/settings.json")] string json)
        => new OkObjectResult(json);
    ```

1. Observe the **GetSettingInfo.cs** file again, which should now include the following code:

    ```csharp
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;

    public static class GetSettingInfo
    {
        [FunctionName("GetSettingInfo")]
        public static IActionResult Run(
            [HttpTrigger("GET")] HttpRequest request,
            [Blob("content/settings.json")] string json)
            => new OkObjectResult(json);
    }
    ```

1. Select **Save** to save your changes to the **GetSettingInfo.cs** file.

## Task 4: Register Azure Storage Blob extensions

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to register the [Microsoft.Azure.WebJobs.Extensions.Storage](https://www.nuget.org/packages/Microsoft.Azure.WebJobs.Extensions.Storage/) extension:

    ```powershell
    func extensions install --package Microsoft.Azure.WebJobs.Extensions.Storage --version 5.0.1
    ```

1. Run the following command to build the .NET project and to validate the extensions were installed correctly:

    ```powershell
    dotnet build
    ```

1. Close all currently running instances of the **Command Prompt** application.

## Task 5: Test the function by using httprepl

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to run the function app project:

    ```powershell
    func start --build
    ```

    > **Note**: You can review the documentation to [start the function app project locally][azure-functions-core-tools-start-function] using the **Azure Functions Core Tools**.
1. On the taskbar, select the **Command Prompt** icon again to open a new instance of the **Command Prompt** application.
1. When you receive the open command prompt, run the following command to start the **httprepl** tool setting the base Uniform Resource Identifier (URI) to ``http://localhost:7071``:

    ```powershell
    httprepl http://localhost:7071
    ```

    > **Note**: An error message is displayed by the **httprepl** tool. This message occurs because the tool is searching for a Swagger definition file to use to traverse the API. Because your function project doesn't produce a Swagger definition file, you'll need to traverse the API manually.

1. When you receive the tool prompt, run the following command to browse to the relative **api** endpoint:

    ```powershell
    cd api
    ```

1. Run the following command to browse to the relative **getsettinginfo** endpoint:

    ```powershell
    cd getsettinginfo
    ```

1. Run the following command to run the **get** command for the current endpoint:

    ```powershell
    get
    ```

1. Observe the JSON content of the response from the function app, which should now include:

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```

1. Run the following command to exit the **httprepl** application:

    ```powershell
    exit
    ```

1. Close all currently running instances of the **Command Prompt** application.


### Review
In this exercise, you created a function that returns the content of a JSON file in Storage.

# Exercise 6: Deploy a local function project to an Azure Functions app

## Task 1: Deploy using the Azure Functions Core Tools

1. On the taskbar, select the **Command Prompt** icon.
1. Run the following command to change the current directory to the **C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func** empty directory:

    ```powershell
    cd C:\AllFiles\AZ-204-DevelopingSolutionsforMicrosoftAzure-master\Allfiles\Labs\02\Starter\func
    ```

1. When you receive the open command prompt, run the following command to login to the Azure Command-Line Interface (CLI):

    ```powershell
    az login
    ```

1. In the **Microsoft Edge** browser window, enter the email address and password for your Microsoft account, and then select **Sign in**.
1. Return to the currently open **Command Prompt** window. Wait for the sign-in process to finish.
1. Run the following command to publish the function app project:

    ```powershell
    func azure functionapp publish <function-app-deployId>
    ```
    > **Note**: You can copy the following Funtion App name as created in this lab, **funclogic<inject key="DeploymentID" enableCopy="true"/>** and replace it in the above command.
    
    > **Note**: For example, if your **Function App name** is **funclogic4532**, your command would be ``func azure functionapp publish funclogic4532``. You can review the documentation to [publish the local function app project][azure-functions-core-tools-publish-azure] using the **Azure Functions Core Tools**.
1. Wait for the deployment to finalize before you move forward with the lab.
1. Close the currently running **Command Prompt** application.

## Task 2: Validate deployment

1. On the taskbar, select the **Microsoft Edge** icon, and select the tab that contains the Azure portal (<https://portal.azure.com>).
1. On the Azure portal's **navigation** pane, select the **Resource groups** link.
1. On the **Resource groups** blade, select the **Serverless-<inject key="DeploymentID" enableCopy="false"/>** resource group that you created previously in this lab.
1. On the **Serverless-<inject key="DeploymentID" enableCopy="false"/>** blade, select the **funclogic<inject key="DeploymentID" enableCopy="false"/>** function app that you created previously in this lab.
1. On the **App Service** blade, select the **Functions** option in the **Functions** section.
1. On the **Functions** pane, select the existing **GetSettingInfo** function.
1. In the **Function** blade, select the **Code + Test** option in the **Developer** section.
1. In the function editor, select **Test/Run**.
1. In the popup dialog that appears, perform the following actions: <!--Conan, as there is only sub step here, can we just combine the two as follows: In the popup dialog that appears, in the **HTTP method** list, select **GET**.-->
    - In the **HTTP method** list, select **GET**.
1. Select **Run** to test the function.
1. Observe the results of the test run in the **Output** section of the same pop-up. The JSON content should now include the following code:

    ```json
    {
        "version": "0.2.4",
        "root": "/usr/libexec/mews_principal/",
        "device": {
            "id": "21e46d2b2b926cba031a23c6919"
        },
        "notifications": {
            "email": "joseph.price@contoso.com",
            "phone": "(425) 555-0162 x4151"
        }
    }
    ```
    The following screenshot displays the Output.

    ![Screenshot displaying the output](./media/AZ-204-2-1.png)
    
    > **Note**: Ignore the message("Application Insights is not configured. Go to the Monitor tab and configure Application Insights to capture function logs.")

 > **Congratulations** on completing the task! Now, it's time to validate it. Here are the steps:

 - Navigate to the Lab Validation Page, from the upper right corner in the lab guide section.
 - Hit the Validate button for the corresponding task. If you receive a success message, you can proceed to the next task. 
 - If not, carefully read the error message and retry the step, following the instructions in the lab guide.
 - If you need any assistance, please contact us at labs-support@spektrasystems.com. We are available 24/7 to help you out.

**You have successfully completed the lab**

### Review

In this exercise, you deployed a local function project to Azure Functions and validated that the functions work in Azure.

